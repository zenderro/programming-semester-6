# Добрый день, группа 312!

### Приближение функции двух переменных
### Заготовка к третьей задаче, OpenGL

andrey.zenzinov@math.msu.ru  

https://zenderro.github.io/programming-semester-6/

<style>
div.left-column {
  width: 44%;
  float: left;
}
div.right-column {
  width: 44%;
  float: right;
}
div.small {
  font-size: 0.8em;
}
div.fullwidth img {
  width: 100% !important;
}
</style>


# Интерполяция тензорными произведениями

Дано:

- исходная функция $f: Z = X × Y → ℝ$, $f∈F(Z,ℝ)$;
- «базисы» $u_i: X → ℝ$, $u_i∈F(X,ℝ)$, $v_j: Y → ℝ$, $v_j∈F(Y,ℝ)$;
- условия интерполяции $λ_i:F(X,ℝ)→ℝ$, $μ_j:F(Y,ℝ)→ℝ$;

Найти: $$Pf = \sum_{i=1}^n\sum_{j=1}^m γ_{i,j}w_{i,j},$$ 
$ν_{i,j}(Pf)=ν_{i,j}(f), i=1,\dots,n, j=1,\dots,m$

$w_{i,j}=u_i⊗v_j, т.е. w_{i,j}=u_i(x)v_j(y)$,

$$nu_{i,j}=λ_i⊗μ_j, т.е. nu_{i,j}(f) = λ_i(μ_j(f_x(y))) = μ_j(λ_i(f_y(x)))$$,

$f_x(y) = f(x,y)∈F(Y,ℝ), f_y(x)=f(x,y)∈F(X,ℝ)$

# Интерполяция тензорными произведениями

Теорема

1. $u_i$ - лин.независимы, $λ_i$ - лин.независимы, матрица $A=(λ_i(u_j))$ - обратима;
2. $v_j$ - лин.независимы, $μ_j$ - лин.независимы, матрица $B=(μ_j(v_i))$ - обратима;

Тогда:

1. $w_{ij}=u_i⊗v_j$ - базис пространства $W=U⊗V, U=⟨u_i⟩, V=⟨v_j⟩$;
2. Задача линейной интерполяции корректна;
3. $$Pf=\sum_{i=1}^n\sum_{j=1}^m γ_{i,j}w_{i,j}, Γ=(γ_{i,j})=A^{-1}((ν_{i,j}(f)))(B^t)^{-1}$$

# Алгоритм интерполяции тензорными произведениями

$Г=A^{-1}F(B^t)^{-1}, F=[f_1,\dots,f_m], f_l=(f_{1l},\dots,f_{nl})^t, f_{kl}=nu_{kl}(f)$

1. $T=A^{-1}F=[A^{-1}f_1,\dots,A^{-1}f_m]$ - вектора коэфф. интерполирующих ф-ий, построенных по $f_k$.
2. $Г=T(B^t)^{-1} = (B^{-1}T^t)^t = [B^{-1}t_1,\dots,B^{-1}t_n]^t$ - вектора коэфф. интерполирующих ф-ий, построенных по $t_l$.

Матрицы $T$ и $Г$ хранятся на месте $F$, поэтому

1. $f_k$ заменяется на $α_k$ - коэфф. интерп. ф-ии $$u=\sum_{i=1}^n α_{ki}u_i: λ_i(f_k)=f_{ik}=λ_i(u)$$
2. $t_l$ заменяется на $β_l$ - коэфф. интерп. ф-ии $$v=\sum_{j=1}^m β_{lj}v_j: μ_j(t_l)=t_{jl}=μ_j(v)$$

# Алгоритм интерполяции тензорными произведениями

- `interp_x(lu, n, alpha)`, `lu`$=(λ_i(u))$, строит вектор коэфф. `alpha`
- `interp_y(mv, m, beta)`, `mv`$=(μ_j(v))$, строит вектор коэфф. `beta`

Коэффициенты для $$Pf(x,y)=\sum_{i=1}^n\sum_{j=1}^m γ_{i,j} u_i(x)v_j(y)$$ строятся по алгоритму:

```
// 1 шаг
for i=1,n
    interp_x(nf[i столбец], n, gamma[i столбец])
```

```
// 2 шаг
for j=1,m
    interp_y(gamma[j строка], m, gamma[j строка])
```

# Программная реализация

Как и во второй задаче для каждого метода нужно написать методы для расчёта коэффициентов `method_init` и вычисления значения приближающей функции `method_compute`.

Графическая часть реализуется с помощью библиотеки OpenGL. В проектный файл .pro добавляется строка:

```
QT += opengl
```


# Требования к программе

Требования доступны по [этой ссылке](require-graph-2D.pdf). Обратите внимание на отличия от требований к задаче 2!

# Заготовка для третьей задачи

Подробное описание заготовки на OpenGL даётся в статье [Работа с OpenGL на Qt4](http://www.wiki.crossplatform.ru/index.php/Работа_с_OpenGL_на_Qt_4_(часть_1)).

Ссылка на задание: [https://classroom.github.com/a/yM-6yqf2](https://classroom.github.com/a/yM-6yqf2). Заготовка будет в созданном репозитории.